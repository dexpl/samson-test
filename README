Результаты выполнения тестового задания https://wiki.intsite.org/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B2_%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%83_%D1%8D%D0%BA%D1%81%D0%BF%D0%BB%D1%83%D0%B0%D1%82%D0%B0%D1%86%D0%B8%D0%B8

Vagrantfile: файл для vagrant, создающий VM в Virtual Box на базе generic/debian9 (восьмой дебиан уже некоторое время как EOL) с требуемыми характеристиками, за исключением жесткого диска: к сожалению, я не знаю на 100% работающего способа изменить жесткий диск у данного vagrant box'а. Способ, предлагаемый в оф. документации (https://www.vagrantup.com/docs/disks/usage) — экспериментальный, поддерживает только virtualbox, да и с ним так просто не работает. Попытка выполнить `vagrant plugin install vagrant-disksize` на Fedora 33 (моя повседневная ОС) закончилась руганью вида 'conflicting dependencies racc (= 1.4.16) and racc (= 1.5.1)'. Вообще, единственно верным решением видится создание собственного бокса, но такое по вечерам после основной работы я бы очень не скоро сделал.
Ввиду того, что по заданию требуется слушать 80-й порт, "говорить" `vagrant up --provider virtualbox` приходится от имени рута.

provision.yml: playbook для ansible, устанавливающий требуемое по заданию ПО и настраивающий apache на порт 8888, а nginx — на проксирование обращений к php-файлам на php-fpm. Вообще, из задания не вполне ясно, как именно apache, nginx и php-fpm должны между собой взаимодействовать, и в реальной работе я бы запросил уточнений, но тут позволил себе импровизацию. Тем более, что по заданию должен быть еще и скрипт на php (о нем ниже). Порт апача и версию php можно передать в виде переменных apache_port и php_version в вызовы ansible-playbook, но не в вызовы vagrant — увы, я пока не настолько хорошо знаю ruby. provision.yml и php.upgrade.yml (см. ниже) "заточены" под дебианоподобные дистрибутивы линукса, но при необходимости их сравнительно просто адаптировать как минимум к редхэтоподобным (применение модуля package вместо apt и файл roles/php/tasks/debian.yml — это задел для такой адаптации). Разнесение задач по ролям упрощает повторное использование (см. php.upgrade.yml).

php.upgrade.yml: playbook для ansible, обновляющий php с 5.6 до 7.2. Точнее, устанавливающий php версии new_php_version (по умолчанию 7.2), удаляющий php версии php_version (по умолчанию 5.6) и перенастраивающий nginx на проксирование запросов к *.php на соответствующий php-fpm.

Makefile: вызывает adhoc-команду ansible для преобразования templates/hello.world.php.j2 в hello.world.php. Преобразование сводится к добавлению shebang и установке разрешения на выполнение. Честно говоря, это чистейшей воды выпендреж вида "смотрите, как я умею", оправданный только тем, что требуемый по заданию скрипт на php получается подходящим как для php-cli, так и для php-fpm, причем для обоих вариантов генерируется из одного шаблона одним и тем же инструментом (такой вот don't repeat yourself).

once3sec.sh: вызов `uname -n`, `date` и `whoami` раз в три секунды; once3sec.nowatch.sh — то же самое, но без использования watch.
